# Load libraries and functions ----
library(tidyverse)
library(demographr)

source("R/utils.R")

# Load indicators - Does not work
indicators <-
  load_indicators(
    path = "data/vulnerability/disasters-emergencies/scotland",
    key = "lad_code"
  ) |>
  select(!c(starts_with("rank"), starts_with("deciles")))

# No indicators to re-align

# Check normality of indicators
indicators |>
  pivot_longer(distances_extent:alone_extent, names_to = "variable", values_to = "value") %>%
  ggplot(aes(x = value)) +
  geom_density() +
  facet_wrap(vars(variable), ncol = 3, scales = "free")

for(i in 2:7) {
  print(colnames(indicators[, i]))
  print(shapiro.test(indicators[[i]])$p.value)
  if (shapiro.test(indicators[[i]])$p.value < 0.05) {
    print("Not normally distributed")
  }
  else {
    print("Normally distributed")
  }
  cat("\n")  
  
}

#dig_vuln, elderly and alone are not normally distributed, distances is at the limit

# Exponential transformation ----

ranked <- indicators |>
  mutate_if(is.numeric, rank)

scale01 <- function(x) (x - min(x))/diff(range(x))

scale_ind <- ranked |>
  mutate_if(is.numeric, scale01)

exponential = function(x) (-23*log(1-x*(1-exp(1)^(-100/23))))

exp_ind <- scale_ind |>
  mutate_if(is.numeric, exponential)

# All are normally distributed after the transformation

# Normalise indicators
normalised <- exp_ind |>
  normalise_indicators(ignore_nas = T)

normalised |>
  pivot_longer(distances_extent:alone_extent, names_to = "variable", values_to = "value") %>%
  ggplot(aes(x = value)) +
  geom_density() +
  facet_wrap(vars(variable), ncol = 3, scales = "free")

# MFLA
standardised = function(x) (x - mean(x))/sd(x)
rank2 = function(x) rank(x, na.last = FALSE)

mfla_score <- function(d) {
  
  # Rank and normalise indicators to mean 0, SD 1.
  d <- d %>%
    mutate_if(is.numeric, list(scaled = function(x) standardised(rank2(x))))
  
  # Extract weights
  d_weights <- d %>%
    select(ends_with("_scaled")) %>%
    factanal(factors = 1) %>%
    tidy() %>%
    select(-uniqueness, weights = fl1) %>%
    mutate(weights = abs(weights),
           weights = weights/sum(weights))
  
  # Multiply model weights by respective column to get weighted indicators
  d_weighted_ind <- d %>%
    select(d_weights$variable) %>%
    map2_dfc(d_weights$weights, `*`) %>%
    select_all(list(~ str_remove(., "_scaled"))) %>%
    select_all(list(~ str_c(., "_weighted")))
  
  # Combine weighted indicators with original data
  d <- bind_cols(d, d_weighted_ind)
  
  # Sum weighted indicators
  d <- d %>%
    mutate(mfla_score = reduce(select(., ends_with("_weighted")), `+`))
  
  # Return data
  return(d)
  
}

#Apply the function
indicators_mfla <- normalised |>
  mfla_score() |>
  select(lad_code,
         mfla_score)

# Domain scores
indicators_scores <- indicators_mfla |>
  calculate_domain_scores(domain_name = "vulnerability") |>
  select(lad_code, deciles = vulnerability_domain_quantiles)

# Another way ----
# Apply transformations to not normal indicators

cor(indicators[,-1], use = "complete.obs")

library(psych)
for(i in 2:7) {
  print(colnames(indicators[, i]))
  print(skew(indicators[[i]]))
  cat("\n")  
  
}

transformed <- indicators |>
  mutate(dig_vuln_extent = sqrt(dig_vuln_extent),
         elderly_extent = sqrt(elderly_extent),
         alone_extent = sqrt(alone_extent))

transformed |>
  pivot_longer(distances_extent:alone_extent, names_to = "variable", values_to = "value") %>%
  ggplot(aes(x = value)) +
  geom_density() +
  facet_wrap(vars(variable), ncol = 3, scales = "free")

for(i in 2:7) {
  print(colnames(transformed[, i]))
  print(shapiro.test(transformed[[i]])$p.value)
  if (shapiro.test(transformed[[i]])$p.value < 0.05) {
    print("Not normally distributed")
  }
  else {
    print("Normally distributed")
  }
  cat("\n")  
  
}

# Normalise indicators
normalised_e <- transformed |>
  normalise_indicators(ignore_nas = T)

normalised_e |>
  pivot_longer(distances_extent:alone_extent, names_to = "variable", values_to = "value") %>%
  ggplot(aes(x = value)) +
  geom_density() +
  facet_wrap(vars(variable), ncol = 3, scales = "free")

indicators_mfla_e <- normalised_e |>
  mfla_score() |>
  select(lad_code,
         mfla_score)

indicators_scores_e <- indicators_mfla_e |>
  calculate_domain_scores(domain_name = "vulnerability") |>
  select(lad_code, deciles = vulnerability_domain_quantiles)

# Comparisons between the different ways----
comparison <- indicators_scores |>
  left_join(indicators_scores_e, by = "lad_code")|>
  mutate(equal = (deciles.x == deciles.y))

table(comparison$equal)
# deciles are not always the same between methods (there are 19 LADs that are different), but they change slightly, e.g. 4th instead of 5th quantile

indicators_scores |>
  write_csv("data/vulnerability/disasters-emergencies/scotland/de-index.csv")